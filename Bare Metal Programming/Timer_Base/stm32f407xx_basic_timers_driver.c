/*
 * stm32f407xx_basic_timers_driver.c
 *
 *  Created on: Aug 31, 2025
 *      Author: Dhruv Satasiya
 */

#include "stm32f407xx_basic_timers_driver.h"		/* Basic Timer Driver Specific header file */

/***********************************************************************************************
 * 						APIs(Application Programming Interface)
 * 							Supported by this driver
 * 			For more information on APIs, check the function declaration(implementation).
 ***********************************************************************************************/
static void TIM_Base_PeriClkEnable(TIM_RegDef_t* pTIMx);
static void TIM_Base_PeriClkDisable(TIM_RegDef_t* PTIMx);

/*
 * @brief	Enables the clock for every TIM Base
 * @param	pTIMx Register Definiton structure address
 * @retval	void - none
 * */
static void TIM_Base_PeriClkEnable(TIM_RegDef_t* pTIMx)
{
	if(pTIMx == TIM6)
	{
		TIM6_PCLK_EN();
	}
	else if(pTIMx == TIM7)
	{
		TIM7_PCLK_EN();
	}
}

/*
 * @brief	Disables the clock for every TIM Base
 * @param	pTIMx Register Definiton structure address
 * @retval	void - none
 * */
static void TIM_Base_PeriClkDisable(TIM_RegDef_t* pTIMx)
{
	if(pTIMx == TIM6)
	{
		TIM6_PCLK_DI();
	}
	if(pTIMx == TIM7)
	{
		TIM7_PCLK_DI();
	}
}

/*
 * @brief	Initializes the Base Timer
 * @param	htim - address to handle of Base Timer
 * @retval	STATUS_Type
 * */
STATUS_Type TIM_Base_Init(TIM_Handle_t* htim)
{
	/* Check the TIM Handle Structure allocation */
	if(htim  == NULL)
	{
		return STATUS_ERROR;
	}

	/* Enable the appropriate clock */
	TIM_Base_PeriClkEnable(htim->pTIMx);

	/* Configure the other parameters of Init structure */
	/* Notice for both here, = is used for assignment not |=,
	 * becasue this is the whole value assingment not only bit settings */
	htim->pTIMx->ARR = (htim->Init.Period);
	htim->pTIMx->PSC = (htim->Init.Prescaler);

	/* Enable Update Interrupt at Base Timer side */
	htim->pTIMx->DIER |= TIM_DIER_UIE;

	/* Enable the IRQ setting and set the priority at Cortex-M4 core side */
	TIM_Base_IRQ_Config(TIM7_IRQn, ENABLE);
	TIM_Base_IRQ_Priority(TIM7_IRQn, 15);

	return STATUS_OK;
}

/*
 * @brief	Starts the Base Timer
 * @param	Address to Handle of Base Timer
 * @retval	None
 * */
void TIM_Base_Start(TIM_Handle_t* htim)
{
	__TIM_BASE_START(htim);
}

/*
 * @brief	Configures the IRQ setting for the Base Timer
 * @param	IRQNumber - TIM Base IRQ number
 * 			EnorDi - Enable or Disable
 * @retval	void
 * */
void TIM_Base_IRQ_Config(IRQn_Type IRQNumber, uint8_t EnorDi)
{
	/*ARM cortex Mx processor side configuration for the interrupts */
	/*NOTE: To configure the Interrupt-set enable registers - as interrupt must be enabled at the processor
	 * side as per the IRQ number to receive it from the external world*/
	if(EnorDi == ENABLE)
	{
		if(IRQNumber <= 31)
		{
			//prorgram ISER0 register
			*NVIC_ISER0 |= (1 << IRQNumber);					/*Do not forget to dereference the address (*NVIC_ISER0) otherwise operation will be performed between address and value*/
		}
		else if(IRQNumber > 31 && IRQNumber <= 64)
		{
			//program ISER1 register
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));
		}
		else if(IRQNumber > 64 && IRQNumber <= 96)
		{
			//program ISER2 register
			*NVIC_ISER2 |= (1 << (IRQNumber % 32));
		}
	}
	/*NOTE: To configure the Interrupt-clear enable registers - as interrupt must be cleared at the processor
	 * side as per the IRQ number once it is done*/
	else
	{
		if(IRQNumber <= 31)
		{
			//program ICER0 register
			*NVIC_ICER0 |= (1 << IRQNumber);

		}
		else if(IRQNumber > 31 && IRQNumber <= 64)
		{
			//program ICER1 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));
		}
		else if(IRQNumber > 64 && IRQNumber <= 96)
		{
			//program ICER2 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));
		}

	}
}

/*
 * @brief	Sets the priority for Base Timer
 * @param	IRQNumber - TIM Base IRQ number
 * 			IRQPriority - provides IRQ priority level
 * @retval	void
 * */
void TIM_Base_IRQ_Priority(IRQn_Type IRQNumber, uint32_t IRQPriority)
{
	//1. find out the IPR register as there are total 60 NVIC registers to set the IRQ priority
	uint8_t iprx = IRQNumber / 4;
	uint8_t iprxSection = IRQNumber % 4;

	uint8_t shiftAmount = (8 * iprxSection) + (8 - NO_PR_BITS_IMPLEMENTED);				// remember because lower nibble is not implemented only upper nibble is.

	*(NVIC_PR_BASEADDR + iprx) |= (IRQPriority << shiftAmount);
}

/*
 * @brief	Handles the Interrupt for Base Timer
 * @param	void
 * @retval	htim - handle to Base Timer
 * */
void TIM_IRQHandler(TIM_Handle_t* htim)
{
	/* Check if interrupt is generated by Overflow, UIF bit in TIMx_SR */
	if((htim->pTIMx->DIER & TIM_DIER_UIE) && (htim->pTIMx->SR & TIM_SR_UIF))
	{
		/* means interrupt has occured due to timer overflow */

		/* 1. first clear the UIF bit by writing 0 to it */
		htim->pTIMx->SR &= ~(TIM_SR_UIF);

		/* 2. call the callback function */
		TIM_Base_PeriodElapsedCallback(htim);
	}
}

/*
 * @brief	Performs the callback task after when timer has overflown
 * @param	Address to TIM Handle
 * @retval	None
 * */
__weak void TIM_Base_PeriodElapsedCallback(TIM_Handle_t* htim)
{
	/* This is weak implementation of period Elapsed callback
	 * User can reimplement it at application side.
	 * */
}
